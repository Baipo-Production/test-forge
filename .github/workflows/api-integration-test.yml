name: TestForge API Integration Test

on:
  workflow_dispatch:
    inputs:
      testName:
        description: 'Test suite name'
        required: false
        default: 'github-action-test'
      inputFile:
        description: 'Path to input CSV/XLSX file (optional, uses example if empty)'
        required: false
        default: ''
  push:
    branches:
      - master
    paths:
      - 'app/**'
      - 'requirements.txt'
      - '.github/workflows/api-integration-test.yml'
  pull_request:
    branches:
      - master

jobs:
  api-integration-test:
    runs-on: ubuntu-latest
    timeout-minutes: 20

    steps:
      # 1. Checkout repository
      - name: ðŸ“¥ Checkout repository
        uses: actions/checkout@v4

      # 2. Setup Python 3.14
      - name: ðŸ Setup Python 3.14
        uses: actions/setup-python@v5
        with:
          python-version: '3.14.0'
          cache: 'pip'

      # 3. Install dependencies
      - name: ðŸ“¦ Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt

      # 4. Start FastAPI server in background
      - name: ðŸš€ Start TestForge API Server
        run: |
          echo "Starting FastAPI server..."
          nohup uvicorn app.main:app --host 0.0.0.0 --port 3000 > server.log 2>&1 &
          echo $! > server.pid
          echo "Server PID: $(cat server.pid)"
        env:
          PYTHONUNBUFFERED: "1"

      # 5. Wait for server to be ready (health check)
      - name: â³ Wait for server health check
        run: |
          echo "Waiting for server to start..."
          for i in {1..30}; do
            if curl -s http://localhost:3000/health > /dev/null 2>&1; then
              echo "âœ… Server is ready!"
              curl http://localhost:3000/health
              break
            fi
            echo "Attempt $i/30 - Server not ready yet, waiting 2s..."
            sleep 2
          done
          
          # Verify server is actually running
          if ! curl -s http://localhost:3000/health > /dev/null 2>&1; then
            echo "âŒ Server failed to start within 60 seconds"
            echo "=== Server Logs ==="
            cat server.log
            exit 1
          fi

      # 6. Action 1: Download example template
      - name: ðŸ“„ Action 1 - Download Example Template
        run: |
          echo "=== Downloading example template ==="
          curl -v -OJ http://localhost:3000/api/v1/download/example-combination-data
          
          # Verify file was downloaded
          if [ -f "example-combination-data.xlsx" ]; then
            echo "âœ… Example template downloaded successfully"
            ls -lh example-combination-data.xlsx
          else
            echo "âŒ Failed to download example template"
            exit 1
          fi

      # 7. Action 2: Generate combinations
      - name: ðŸ”„ Action 2 - Generate Combinations
        run: |
          echo "=== Generating test combinations ==="
          
          # Use custom input file if provided, otherwise use example template
          if [ -n "${{ github.event.inputs.inputFile }}" ] && [ -f "${{ github.event.inputs.inputFile }}" ]; then
            INPUT_FILE="${{ github.event.inputs.inputFile }}"
            echo "Using custom input file: $INPUT_FILE"
          else
            INPUT_FILE="example-combination-data.xlsx"
            echo "Using example template as input"
          fi
          
          curl -v -X POST http://localhost:3000/api/v1/combination-test-case \
            -F "file=@$INPUT_FILE" \
            -o combination_output.xlsx
          
          # Verify output
          if [ -f "combination_output.xlsx" ]; then
            echo "âœ… Combinations generated successfully"
            ls -lh combination_output.xlsx
          else
            echo "âŒ Failed to generate combinations"
            exit 1
          fi

      # 8. Prepare filled data for compilation
      - name: ðŸ“ Prepare Filled Test Data
        run: |
          echo "=== Preparing test data for compilation ==="
          
          # For this example, we'll use the combination output directly
          # In production, user would manually fill [Response] columns
          # Here we'll copy and use it as-is (Robot tests will validate structure)
          cp combination_output.xlsx filled_testdata.xlsx
          
          echo "âœ… Test data prepared"
          ls -lh filled_testdata.xlsx

      # 9. Action 3: Compile test cases
      - name: ðŸ”¨ Action 3 - Compile Test Cases
        id: compile
        run: |
          echo "=== Compiling test cases to Robot Framework ==="
          
          TEST_NAME="${{ github.event.inputs.testName || 'github-action-test' }}"
          
          RESPONSE=$(curl -v -X POST http://localhost:3000/api/v1/compile-test-case \
            -F "testName=$TEST_NAME" \
            -F "file=@filled_testdata.xlsx")
          
          echo "$RESPONSE"
          echo "$RESPONSE" > compile_response.json
          
          # Extract run_url from response
          RUN_URL=$(echo "$RESPONSE" | jq -r '.run_url // empty')
          echo "run_url=$RUN_URL" >> $GITHUB_OUTPUT
          
          # Verify compilation succeeded
          STATUS=$(echo "$RESPONSE" | jq -r '.status // empty')
          if [ "$STATUS" = "compiled" ]; then
            CASES=$(echo "$RESPONSE" | jq -r '.cases // 0')
            echo "âœ… Compiled $CASES test cases successfully"
          else
            echo "âŒ Compilation failed"
            echo "Response: $RESPONSE"
            exit 1
          fi

      # 10. Action 4: Run tests with SSE streaming
      - name: ðŸƒ Action 4 - Run Tests (SSE Stream)
        id: run_tests
        run: |
          echo "=== Running Robot Framework tests ==="
          
          TEST_NAME="${{ github.event.inputs.testName || 'github-action-test' }}"
          STREAM_URL="http://localhost:3000/api/v1/run-test-case/$TEST_NAME/stream"
          
          echo "Streaming from: $STREAM_URL"
          
          # Use curl with --no-buffer to handle SSE stream
          # Save output to file and display in real-time
          curl -N --no-buffer "$STREAM_URL" 2>&1 | tee sse_output.log
          
          # Extract timestamp from SSE done event (last event with download_url)
          TIMESTAMP=$(grep -o '"timestamp":"[^"]*"' sse_output.log | tail -1 | cut -d'"' -f4 || echo "")
          
          if [ -n "$TIMESTAMP" ]; then
            echo "timestamp=$TIMESTAMP" >> $GITHUB_OUTPUT
            echo "âœ… Tests completed with timestamp: $TIMESTAMP"
          else
            echo "âš ï¸ Could not extract timestamp, will download latest report"
            echo "timestamp=" >> $GITHUB_OUTPUT
          fi

      # 11. Action 5: Download test report
      - name: ðŸ“Š Action 5 - Download Test Report
        id: download_report
        continue-on-error: true
        run: |
          echo "=== Downloading test report ==="
          
          TEST_NAME="${{ github.event.inputs.testName || 'github-action-test' }}"
          TIMESTAMP="${{ steps.run_tests.outputs.timestamp }}"
          
          if [ -n "$TIMESTAMP" ]; then
            DOWNLOAD_URL="http://localhost:3000/api/v1/download/$TEST_NAME/$TIMESTAMP"
            OUTPUT_FILE="${TEST_NAME}_Report_${TIMESTAMP}.zip"
            echo "Downloading specific report: $TIMESTAMP"
          else
            DOWNLOAD_URL="http://localhost:3000/api/v1/download/$TEST_NAME"
            OUTPUT_FILE="${TEST_NAME}_Report_latest.zip"
            echo "Downloading latest report"
          fi
          
          echo "URL: $DOWNLOAD_URL"
          echo "Output file: $OUTPUT_FILE"
          
          # Download with explicit output filename
          HTTP_CODE=$(curl -w "%{http_code}" -o "$OUTPUT_FILE" "$DOWNLOAD_URL")
          echo "HTTP Status: $HTTP_CODE"
          
          if [ "$HTTP_CODE" -eq 200 ]; then
            echo "âœ… Report downloaded successfully!"
            ls -lh "$OUTPUT_FILE"
          else
            echo "âš ï¸ Download failed with status $HTTP_CODE (report may not exist yet)"
            rm -f "$OUTPUT_FILE"
          fi

      # 12. Upload test artifacts
      - name: ðŸ“¤ Upload Test Artifacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: testforge-reports-${{ github.event.inputs.testName || 'github-action-test' }}
          path: |
            *.xlsx
            *.json
            *.log
            *_Report_*.zip
          retention-days: 30
          if-no-files-found: warn

      # 13. Display summary
      - name: ðŸ“‹ Test Summary
        if: always()
        run: |
          echo "=== TestForge API Integration Test Summary ==="
          echo ""
          echo "ðŸ“Š Test Name: ${{ github.event.inputs.testName || 'github-action-test' }}"
          echo "ðŸ• Timestamp: ${{ steps.run_tests.outputs.timestamp || 'N/A' }}"
          echo ""
          echo "ðŸ“ Generated Files:"
          ls -lh *.xlsx *.json *.log *.zip 2>/dev/null || echo "No files generated"
          echo ""
          echo "ðŸ”— Download artifacts from: https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}"

      # 14. Cleanup: Stop server
      - name: ðŸ›‘ Stop FastAPI Server
        if: always()
        run: |
          if [ -f server.pid ]; then
            PID=$(cat server.pid)
            echo "Stopping server with PID: $PID"
            kill $PID 2>/dev/null || echo "Server already stopped"
          fi
          
          echo "=== Final Server Logs ==="
          cat server.log || echo "No server logs available"
